#define _SIZE_T_DEFINED_
#include <libspu.h>
#include <libsnd.h>


#include "standard.h"

#include "malloc.h"
#include "tim.h"
#include "object.h"
#include "file.h"
#include "skeleton.h"
#include "track.h"
#include "ships.h"
#include "weapon.h"
#include "control.h"
#include "droid.h"
#include "camera.h"
#include "sound.h"
#include "sparks2.h"
#include "menus.h"
#include "global.h"

#include "..\chrise\utypes.h"
#include "..\chrise\sfx.h"
#include "c:\wc10\h\stdio.h"

#define NO_SOUND	1

#define	MAX_FX		30

uint8 ConvVol(short left, short right);
uint8 ConvPan(short left, short right);
uint8 ConvCDVol(int16 LeftVol, int16 RightVol);

int16				sfx_handle[MAX_FX]; // PC sound
int16				error;				// PC sound
SampRec				SampTable[MAX_FX];	// PC Sound
int16				Channel2Sample[24];	// PC Sound

//extern	uint16	wSfxDefault_UseAwe32G; //New library version

static signed char	bOrg,bImg;							   //PC File handling gubbins
static uint8		*pHeadPtr, *pOrgPtr,*pImgPtr;
static FILE 		*pHeadFile,*pOrgFile,*pImgFile;
static char 		pbFileName[80];
static uint8		bIndx;
static int16		wFirstId;

/*
 ** FileSize
 *
 *  FILENAME: c:\source\wipeout2\origsrc\sound.c
 *
 *  PARAMETERS:	*infile
 *
 *  DESCRIPTION: Gets length of file
 *
 *  RETURNS: long size
 *
 */

long FileSize(FILE *infile)
{
 long 		curpos;
 long 		size;
 short		error;

 curpos = ftell(infile);
 fseek(infile,0,SEEK_END);
 size = ftell(infile);
 fseek(infile,curpos,SEEK_SET);
 return(size);
}

/*
 ** ConVol
 *
 *  FILENAME: c:\source\wipeout2\origsrc\sound.c
 *
 *  PARAMETERS:	shorts left & right volume
 *
 *  DESCRIPTION: Converts spu vol to PC val
 *
 *  RETURNS: uint 8 PCVol
 *
 */

uint8 ConvVol(short left, short right)
 {
  long Sum;
  uint8 PCVol;

  Sum = left+right;
  Sum /= 2;
  PCVol = Sum >>6;
  return(PCVol); 
 }

 /*
 ** ConvPan
 *
 *  FILENAME: c:\source\wipeout2\origsrc\sound.c
 *
 *  PARAMETERS:	shorts left & right vol
 *
 *  DESCRIPTION: Gets PC pan val
 *
 *  RETURNS: unint8 PCPan
 *
 */

 uint8 ConvPan(short left, short right)
  {
   float ratio;
   uint8 PCPan;

   ratio = (float)left/right;
   
   if (ratio ==1)
	{
	 PCPan=15;
	}
   else
	if (ratio >1)
	 {
	  PCPan = (uint8)((uint16) ratio >>13);
	 }
	else
	 {
	  PCPan = (uint8)((uint16) ratio >>13)+15;
	 }

	if (PCPan>30)
	 PCPan =30;

	return(PCPan);
  }

  /*
 ** ConvPitch
 *
 *  FILENAME: c:\source\wipeout2\origsrc\sound.c
 *
 *  PARAMETERS:	uint16 Pitch
 *
 *  DESCRIPTION: converts spu pitch to PC pitch
 *
 *  RETURNS: uint16 PCPitch;
 *
 */

uint16 ConvPitch(uint16 Pitch)
  {
   uint16 PCPitch;

   if (Pitch < 0x800)
	Pitch=0x800;

   if (Pitch >0x3fff)
	Pitch =0x3fff;

   if (Pitch==0x3fff)
	PCPitch=768;

   if ((Pitch>=0x800) && (Pitch<0x1000))
    {
     PCPitch = (((Pitch-0x800)>>1)+128);
	}

   if ((Pitch>=0x1000) && (Pitch<0x2000))
	{
	 PCPitch = (((Pitch-0x1000)>>4)+256);
	}

   if ((Pitch>=0x2000) && (Pitch<0x3fff))
	{
	 PCPitch = (((PCPitch-0x2000)>>5)+512);
	}
	PCPitch*=2;

   return(PCPitch);
  }
   /*

 ** ConvCDVol
 *
 *  FILENAME: c:\source\wipeout2\origsrc\sound.c
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */
uint8 ConvCDVol(int16 LeftVol, int16 RightVol)
 {
  int16 CDVol;
  uint8 PCVol;

  CDVol=(LeftVol+RightVol)/2;
  PCVol=(uint8)(CDVol>>7);

  return(PCVol);
 }

/************************************************************/
/***** Initialises the sound sub system, loads VAB file *****/
/*****  & sets channel manager                          *****/
/************************************************************/


void InitSpuSound()
{
 int		i;
 long		decval;
 

// wSfxDefault_UseAwe32G = 0;	//don't attempt to use new AWE code.

// error = SfxInit(AUTO_DETECT,MONO,SR_22K);  
// if (getenv("windir") != NULL)
//	 error = SfxInit(SOUNDBLASTER,STEREO,SR_22K);  
// else
	 error = SfxInit(AUTO_DETECT,STEREO,SR_22K);  
 if (error !=1)
 {
	/* Load bank header file */

 pHeadFile=fopen("\\wipeout\\SFX\\WOFX.FXH","rb");
 pHeadPtr=(uint8 *)malloc(FileSize(pHeadFile));
 fread(pHeadPtr,1,FileSize(pHeadFile),pHeadFile);

 /* Load bank body */
 
// SfxGetFxBank (&bOrg, &bImg,NULL,NULL); //New Lib version
 SfxGetFxBank (&bOrg, &bImg);
 sprintf(pbFileName,"\\wipeout\\sfx\\wofx.fx%d",bOrg);
 pOrgFile=fopen(pbFileName,"rb");

 if((pOrgPtr=(uint8 *)malloc(FileSize(pOrgFile))) == NULL)
  {
   printf("Not enough memory for sound\n");

	for(decval = 128; (pOrgPtr=(uint8 *)malloc(FileSize(pOrgFile) - decval)) == NULL; decval += 128);

	printf("Could only malloc %d bytes\n", FileSize(pOrgFile) - decval);
	printf("Need another %d bytes\n", decval);
	error =1;
	getch();
   }


 fread(pOrgPtr,1,FileSize(pOrgFile),pOrgFile);

 /* Open FX Bank */

// SfxOpenFxBank(pHeadPtr,pOrgPtr,pImgPtr,NULL,NULL,&wFirstId); //New Library version, but those NULLs should really be in32 ptrs!
 SfxOpenFxBank(pHeadPtr,pOrgPtr,pImgPtr,&wFirstId);
 free(pHeadPtr);

 /* Build Handles To FX*/

 for(bIndx=0;bIndx<MAX_FX;bIndx++)
  {
   sfx_handle[bIndx] = wFirstId+bIndx;
  }
}

 /*
 flag = 0;

 for(i = 0; i < MAX_FX; i++)
  {
   if (sfx_handle[i] < 0)
	{
	 printf("sfx_handle[%d] = %d\n",i,sfx_handle[i]);
	 flag = 1;
	}
  }

 if (flag == 1)
 exit(-1);
 */		//CHRIS PC Debug Info
 
 // SetUp Sample Info per Sample

 for(i = 0; i < MAX_FX; i++)
  {
   SampTable[i].SampVol =255;
   SampTable[i].SampPan =15;
   SampTable[i].SampPitch =256;
   
    if (i==ENG_AIR_INTAKE ||
   	    i==ENG_RUMBLE ||
   	    i==ENG_THRUST ||
   	    i==REMOTE_ENG ||
   	    i==SHIELDS ||
   	    i==TRACTOR_BEAM ||
   	    i==TURBULENCE ||
   	    i==CROWD)
	 {   
	  SampTable[i].Loop =1;
	 }
	else
	 {
	  SampTable[i].Loop=0;
   	 }

   SampTable[i].Playing =0;
  }

  if (error !=NO_SOUND)
   {
    SfxSetMaxEffects(8);  
    SfxSetVolume(255); 	
    SfxOn();

  /** Init Reverb **/
    SfxInitReverb(REVERB,100);
    SfxSetReverbDepth(64);
    SfxReverbOff();
   }

	for(i = 1; i < 24; i++)
	{
     chanTable[i].s_attr.mask = (SPU_VOICE_VOLL |
 	  	   						 SPU_VOICE_VOLR |
 		   						 SPU_VOICE_VOLMODEL |
 		   						 SPU_VOICE_VOLMODER |
 		   						 SPU_VOICE_PITCH |
 		   						 SPU_VOICE_WDSA |
 		  						 SPU_VOICE_ADSR_AMODE |
 		   						 SPU_VOICE_ADSR_SMODE |
 		   						 SPU_VOICE_ADSR_RMODE |
 		   						 SPU_VOICE_ADSR_AR |
 		   						 SPU_VOICE_ADSR_DR |
 		   						 SPU_VOICE_ADSR_SR |
 		   						 SPU_VOICE_ADSR_RR |
 		   						 SPU_VOICE_ADSR_SL
 		   						);

     chanTable[i].s_attr.voice 		  = (0x1L << i);
     chanTable[i].s_attr.volume.left  = 0x1fff;					// Left volume  //0x3fff 
     chanTable[i].s_attr.volume.right = 0x1fff;					// Right volume 
     chanTable[i].s_attr.volmode.left = SPU_VOICE_DIRECT;		// Right volume 
     chanTable[i].s_attr.volmode.right= SPU_VOICE_DIRECT;		// Right volume 
     chanTable[i].s_attr.pitch        = 0x800;					// Pitch 
     chanTable[i].s_attr.addr         = 0;						// Waveform data start address 
     chanTable[i].s_attr.a_mode       = SPU_VOICE_LINEARIncN;	// Attack curve 
     chanTable[i].s_attr.s_mode       = SPU_VOICE_LINEARIncN;	// Sustain curve 
     chanTable[i].s_attr.r_mode       = SPU_VOICE_LINEARDecN;	// Release curve 
     chanTable[i].s_attr.ar           = 0x0;					// Attack rate value 
     chanTable[i].s_attr.dr           = 0x0;					// Decay rate value 
     chanTable[i].s_attr.sr           = 0x0;					// Sustain rate value 
     chanTable[i].s_attr.rr           = 0x0;					// Release rate value 
     chanTable[i].s_attr.sl           = 0xf;					// Sustain level value //

 	 chanTable[i].duration = 0;

 	 Channel2Sample[i] = -1;		//Chris PCWipeout
	}

  	chanTable[POWER_UP].s_attr.pitch = 0x0800;

	r_attr.mask = (	SPU_REV_MODE |
							SPU_REV_DEPTHL |
							SPU_REV_DEPTHR);

	r_attr.mode = SPU_REV_MODE_CLEAR_WA | SPU_REV_MODE_HALL;
	r_attr.depth.left = 2000;
	r_attr.depth.right = 2000;

  	/*
	SpuSetReverbModeParam(&r_attr);
	SpuReserveReverbWorkArea(SpuOn);
	SpuSetReverbDepth(&r_attr);
	SpuSetReverbVoice(SpuOn, SPU_ALLCH);

	SpuSetReverb(SpuOn);
  /
   c_attr.mask = (	SPU_COMMON_MVOLL |
						 	SPU_COMMON_MVOLR |
						 	SPU_COMMON_CDVOLL |
						 	SPU_COMMON_CDVOLR |
							SPU_COMMON_CDMIX |
							SPU_COMMON_CDREV);

   // See Menus for default level calculation 

   c_attr.mvol.left  = 5134;			// Master volume (left) 
   c_attr.mvol.right = 5134;			// Master volume (right)
 */
   c_attr.cd.volume.left  = 22500;		// Master volume (left) 
   c_attr.cd.volume.right  = 22500;	// Master volume (right) 
 /*
   c_attr.cd.mix = SpuOn;	   
   c_attr.cd.reverb = SpuOn;	   
   */
   
   sampleLevel = 8190;

  /*
   SpuSetCommonAttr (&c_attr) */	//CHRIS PC Wipeout
  
   SfxSetCdVolume(ConvCDVol(c_attr.cd.volume.left,c_attr.cd.volume.right));
   
 /* Initialise Effects */
 

}	

/*
u_long FindVagInVab (u_long SBaddr, short vagNo)
{
	VabHdr		*vabhdr;
	short			*vagtable;
	u_long 		offset;
	short 		count;

	vabhdr = (VabHdr *)soundHead;

	vagtable = (short *)((u_long)soundHead + sizeof(VabHdr) +
					(u_long)(128 * sizeof(ProgAtr)) +
					(u_long)(sizeof(VagAtr) * 16 * vabhdr->ps));

	offset = 0;

	for(count = 0; count < vagNo; count++)
	{
		offset += (((u_long)((u_short)*vagtable))<<3);
		vagtable++;
	}
   return(SBaddr + offset);		// Waveform data start address 
}
#if 0
void DrawChannels()
{
	static POLY_F4 chans[24];
	int i;

	for(i = 0; i < 24; i++)
	{
		SetPolyF4(&(chans[i]));			
		if(vagTable[CROWD].channelID == i)
		{

			chans[i].r0=0x0;
			chans[i].g0=0xff;
			chans[i].b0=0x0;
		}
		else
		{
			chans[i].r0=0xff;
			chans[i].g0=0x0;
			chans[i].b0=0x0;
		}
		setXY4(&(chans[i]),(i+2)*10   ,50,
						 		 (i+3)*10   ,50,
						 		 (i+2)*10   ,50 + chanTable[i].duration,
						 		 (i+3)*10   ,50 + chanTable[i].duration);
 		AddPrim(OT[CurrentScreen], (POLY_F4 *)&(chans[i]));
	}
}	
#endif
*/	  //CHRIS	PC Wipeout 
	
void UpdateNotes(int paused)
{
 int i;
 static int mode = NOT_PAUSED;
 static SpuVolume pauseVol[24];
	
 if((paused == PAUSED) && (mode != PAUSED))
  {	
   mode = PAUSED;
   for(i = 1; i < 24; i++)
	{
	 pauseVol[i].left = chanTable[i].s_attr.volume.left;
	 pauseVol[i].right = chanTable[i].s_attr.volume.right;
    }
  }
 else if((paused == PAUSED) && (mode == PAUSED))
  {	
   for(i = 1; i < 24; i++)
	{
  	 chanTable[i].s_attr.volume.left  -= chanTable[i].s_attr.volume.left>>3;		/* Left volume *//* 0x3fff */
  	 chanTable[i].s_attr.volume.right -= chanTable[i].s_attr.volume.right>>3;		/* Right volume */
	 //SpuSetVoiceAttr(&(chanTable[i].s_attr));
			
	 if ((chanTable[i].s_attr.volume.left==0) && (chanTable[i].s_attr.volume.right==0))
	  {
	   if ((error!=NO_SOUND) && (Channel2Sample[i]!=-1))				   //	If we can have sound and sample is playing
		{
		 if((SampTable[Channel2Sample[i]].Playing !=0) && (SampTable[Channel2Sample[i]].Loop !=0))	// If sample loops
		  {
		   SfxStop(SampTable[Channel2Sample[i]].PlayID);
		   SampTable[Channel2Sample[i]].Playing=0;
		   SampTable[Channel2Sample[i]].PlayID=-1;
		  }
		}
	  }
	 else
	  {
	   if ((error!=NO_SOUND) && (Channel2Sample[i]!=-1))				   //	If we can have sound and sample is playing
		{
		 if((SampTable[Channel2Sample[i]].Playing !=0) && (SampTable[Channel2Sample[i]].Loop !=0))	// If sample loops
		  {
		   //SpuSetVoiceAttr(&(chanTable[i].s_attr));	//PAH! CHRIS PCWipeout
		   SfxEffectPitch(SampTable[Channel2Sample[i]].PlayID,ConvPitch(chanTable[i].s_attr.pitch));
		   SfxEffectVol(SampTable[Channel2Sample[i]].PlayID,ConvVol(chanTable[i].s_attr.volume.left,chanTable[i].s_attr.volume.right));
		   SfxEffectPan(SampTable[Channel2Sample[i]].PlayID,ConvPan(chanTable[i].s_attr.volume.left,chanTable[i].s_attr.volume.right));
		  }
		}
	  }

	 if(chanTable[i].duration == 1)
	  {
	   if ((error!=NO_SOUND) && (Channel2Sample[i]!=-1))			//	If we can have sound and sample is playing		
	    {
	     if((SampTable[Channel2Sample[i]].Playing !=0) && (SampTable[Channel2Sample[i]].Loop !=0))  // If sample loops	
		  {
		   //SpuSetKey(SpuOff, (0x1L << i)); PAH! CHRIS PCWipeout
		   SfxStop(SampTable[Channel2Sample[i]].PlayID);
		   SampTable[Channel2Sample[i]].Playing=0;
		   SampTable[Channel2Sample[i]].PlayID=-1;
	      }
	    }
	  }

	 if(chanTable[i].duration > 0)
	  {
	   chanTable[i].duration--;
	  }
    }
  }
 else if((paused != PAUSED) && (mode == PAUSED))
  {	
   mode = NOT_PAUSED;
   for(i = 1; i < 24; i++)
	{
  	 chanTable[i].s_attr.volume.left  = pauseVol[i].left ;		/* Left volume *//* 0x3fff */
  	 chanTable[i].s_attr.volume.right = pauseVol[i].right;		/* Right volume */
			
	 if ((error!=NO_SOUND) && (Channel2Sample[i]!=-1))				   //	If we can have sound and sample is playing
	  {
	   if((SampTable[Channel2Sample[i]].Playing !=0) && (SampTable[Channel2Sample[i]].Loop !=0))	// If sample loops
		{
		 //SpuSetVoiceAttr(&(chanTable[i].s_attr));
		 SfxEffectPitch(SampTable[Channel2Sample[i]].PlayID,ConvPitch(chanTable[i].s_attr.pitch));
		 SfxEffectVol(SampTable[Channel2Sample[i]].PlayID,ConvVol(chanTable[i].s_attr.volume.left,chanTable[i].s_attr.volume.right));
		 SfxEffectPan(SampTable[Channel2Sample[i]].PlayID,ConvPan(chanTable[i].s_attr.volume.left,chanTable[i].s_attr.volume.right));
	    }
	  }
    }
  }
 else
  {
   for(i = 1; i < 24; i++)
	{
	 if((chanTable[i].duration < 10) && (chanTable[i].duration > 0))
	  {
  	   chanTable[i].s_attr.volume.left  -= chanTable[i].s_attr.volume.left>>2;		/* Left volume *//* 0x3fff */
  	   chanTable[i].s_attr.volume.right -= chanTable[i].s_attr.volume.right>>2;		/* Right volume */
	   
	   if ((error!=NO_SOUND) && (Channel2Sample[i]!=-1))				   //	If we can have sound and sample is playing
		{
		 if((SampTable[Channel2Sample[i]].Playing !=0) && (SampTable[Channel2Sample[i]].Loop !=0))	// If sample loops
		  {
		   //SpuSetVoiceAttr(&(chanTable[i].s_attr));
		   SfxEffectPitch(SampTable[Channel2Sample[i]].PlayID,ConvPitch(chanTable[i].s_attr.pitch));
		   SfxEffectVol(SampTable[Channel2Sample[i]].PlayID,ConvVol(chanTable[i].s_attr.volume.left,chanTable[i].s_attr.volume.right));
		   SfxEffectPan(SampTable[Channel2Sample[i]].PlayID,ConvPan(chanTable[i].s_attr.volume.left,chanTable[i].s_attr.volume.right));
		  }
		}
	  }

	 if(chanTable[i].duration == 1)
	  {
	   if ((error!=NO_SOUND) && (Channel2Sample[i]!=-1))			//	If we can have sound and sample is playing		
		{
		 if((SampTable[Channel2Sample[i]].Playing !=0) && (SampTable[Channel2Sample[i]].Loop !=0))  // If sample loops	
		  {
		   //SpuSetKey(SpuOff, (0x1L << i)); PAH! CHRIS PCWipeout
		   SfxStop(SampTable[Channel2Sample[i]].PlayID);
		   SampTable[Channel2Sample[i]].Playing=0;
		   SampTable[Channel2Sample[i]].PlayID=-1;
		  }
	   	}
	  }

	 if(chanTable[i].duration > 0)
	  {
	   chanTable[i].duration--;
	  }
	}
  }
}	

void KillNote(int note)
{
 short i;
 short channel;
 
 channel =-1;

 for(i = 1; i < 24; i++)
  {
   if ((SampTable[note].PlayID == Channel2Sample[i]) && (SampTable[note].PlayID !=-1))
	{
	 channel=i;
	}
  }

 if ((channel!=-1) && (error!=NO_SOUND))
  {
   if((SampTable[note].Playing !=0) && (SampTable[note].Loop !=0)) 
	{
	 SfxStop(SampTable[note].PlayID);
	 SampTable[note].Playing = 0;
	 chanTable[channel].duration = 0;	
	}
  }
/*	SpuSetVoiceAttr(&(chanTable[vagTable[note].channelID].s_attr));*/
}


void KillNotes()
{
 	int i;

	for(i = 1; i < 24; i++)
	{
	 if ((error!=NO_SOUND) && (Channel2Sample[i]!=-1))			//	If we can have sound and sample is playing		
	  {
	   if((SampTable[Channel2Sample[i]].Playing !=0) && (SampTable[Channel2Sample[i]].Loop !=0))  // If sample loops	
		{
		 //SpuSetKey(SpuOff, (0x1L << i)); PAH! CHRIS PCWipeout
		 SfxStop(SampTable[Channel2Sample[i]].PlayID);
		 SampTable[Channel2Sample[i]].Playing=0;
		 SampTable[Channel2Sample[i]].PlayID=-1;
		}
	  }


   	chanTable[i].s_attr.volume.left  = 0x1fff;		// Left volume // 0x3fff 
   	chanTable[i].s_attr.volume.right = 0x1fff;		// Right volume 
   	chanTable[i].s_attr.volmode.left = SPU_VOICE_DIRECT;		// Right volume 
   	chanTable[i].s_attr.volmode.right= SPU_VOICE_DIRECT;		// Right volume 
   	chanTable[i].s_attr.pitch        = 0x800;		// Pitch 
   	chanTable[i].s_attr.addr         = 0;		// Waveform data start address 
   	chanTable[i].s_attr.a_mode       = SPU_VOICE_LINEARIncN;	// Attack curve 
   	chanTable[i].s_attr.s_mode       = SPU_VOICE_LINEARIncN;	// Sustain curve
   	chanTable[i].s_attr.r_mode       = SPU_VOICE_LINEARDecN;	// Release curve
   	chanTable[i].s_attr.ar           = 0x0;			// Attack rate value 
   	chanTable[i].s_attr.dr           = 0x0;			// Decay rate value 
   	chanTable[i].s_attr.sr           = 0x0;			// Sustain rate value 
   	chanTable[i].s_attr.rr           = 0x0;			// Release rate value 
   	chanTable[i].s_attr.sl           = 0xf;			// Sustain level value 

		chanTable[i].duration = 0;
		
		if ((error!=NO_SOUND) && (Channel2Sample[i]!=-1))				   //	If we can have sound and sample is playing
		 {
		  if((SampTable[Channel2Sample[i]].Playing !=0) && (SampTable[Channel2Sample[i]].Loop !=0))	// If sample loops
		   {
			//SpuSetVoiceAttr(&(chanTable[i].s_attr));	//PAH! CHRIS PCWipeout
			SfxEffectPitch(SampTable[Channel2Sample[i]].PlayID,ConvPitch(chanTable[i].s_attr.pitch));
			SfxEffectVol(SampTable[Channel2Sample[i]].PlayID,ConvVol(chanTable[i].s_attr.volume.left,chanTable[i].s_attr.volume.right));
		    SfxEffectPan(SampTable[Channel2Sample[i]].PlayID,ConvPan(chanTable[i].s_attr.volume.left,chanTable[i].s_attr.volume.right));
		   }
		 }
	}
}  

void KillFadeNotes()
{
	int i, j;

	for (j = 0; j < 10; j++)
	{
		for(i = 1; i < 24; i++)
		{
  			chanTable[i].s_attr.volume.left  -= chanTable[i].s_attr.volume.left>>3;		/* Left volume *//* 0x3fff */
  			chanTable[i].s_attr.volume.right -= chanTable[i].s_attr.volume.right>>3;		/* Right volume */
			
			if ((error!=NO_SOUND) && (Channel2Sample[i]!=-1))				   //	If we can have sound and sample is playing
		 	 {
		  	  if((SampTable[Channel2Sample[i]].Playing !=0) && (SampTable[Channel2Sample[i]].Loop !=0))	// If sample loops
		       {
			    //SpuSetVoiceAttr(&(chanTable[i].s_attr));	//PAH! CHRIS PCWipeout
			    SfxEffectPitch(SampTable[Channel2Sample[i]].PlayID,ConvPitch(chanTable[i].s_attr.pitch));
			    SfxEffectVol(SampTable[Channel2Sample[i]].PlayID,ConvVol(chanTable[i].s_attr.volume.left,chanTable[i].s_attr.volume.right));
		   	    SfxEffectPan(SampTable[Channel2Sample[i]].PlayID,ConvPan(chanTable[i].s_attr.volume.left,chanTable[i].s_attr.volume.right));
		       }
		     }
			
//			VSync(0);
		}
	}

	for(i = 1; i < 24; i++)
	{
	 if ((error!=NO_SOUND) && (Channel2Sample[i]!=-1))			//	If we can have sound and sample is playing		
	  {
	   if((SampTable[Channel2Sample[i]].Playing !=0) && (SampTable[Channel2Sample[i]].Loop !=0))  // If sample loops	
		{
		 //SpuSetKey(SpuOff, (0x1L << i)); PAH! CHRIS PCWipeout
		 SfxStop(SampTable[Channel2Sample[i]].PlayID);
		 SampTable[Channel2Sample[i]].Playing=0;
		 SampTable[Channel2Sample[i]].PlayID=-1;
		} 
	  }

  		chanTable[i].s_attr.volume.left  = 0x1fff;		/* Left volume *//* 0x3fff */
  		chanTable[i].s_attr.volume.right = 0x1fff;		/* Right volume */
  		chanTable[i].s_attr.volmode.left = SPU_VOICE_DIRECT;		/* Right volume */
  		chanTable[i].s_attr.volmode.right= SPU_VOICE_DIRECT;		/* Right volume */
  		chanTable[i].s_attr.pitch        = 0x800;		/* Pitch */
  		chanTable[i].s_attr.addr         = 0;		/* Waveform data start address */
  		chanTable[i].s_attr.a_mode       = SPU_VOICE_LINEARIncN;	/* Attack curve */
  		chanTable[i].s_attr.s_mode       = SPU_VOICE_LINEARIncN;	/* Sustain curve */
  		chanTable[i].s_attr.r_mode       = SPU_VOICE_LINEARDecN;	/* Release curve */
  		chanTable[i].s_attr.ar           = 0x0;			/* Attack rate value */
  		chanTable[i].s_attr.dr           = 0x0;			/* Decay rate value */
  		chanTable[i].s_attr.sr           = 0x0;			/* Sustain rate value */
  		chanTable[i].s_attr.rr           = 0x0;			/* Release rate value */
  		chanTable[i].s_attr.sl           = 0xf;			/* Sustain level value */
		chanTable[i].duration = 0;
	
		if ((error!=NO_SOUND) && (Channel2Sample[i]!=-1))				   //	If we can have sound and sample is playing
		 {
		  if((SampTable[Channel2Sample[i]].Playing !=0) && (SampTable[Channel2Sample[i]].Loop !=0))	// If sample loops
		   {
		    //SpuSetVoiceAttr(&(chanTable[i].s_attr));	//PAH! CHRIS PCWipeout
		    SfxEffectPitch(SampTable[Channel2Sample[i]].PlayID,ConvPitch(chanTable[i].s_attr.pitch));
		    SfxEffectVol(SampTable[Channel2Sample[i]].PlayID,ConvVol(chanTable[i].s_attr.volume.left,chanTable[i].s_attr.volume.right));
		    SfxEffectPan(SampTable[Channel2Sample[i]].PlayID,ConvPan(chanTable[i].s_attr.volume.left,chanTable[i].s_attr.volume.right));
		   }
		 }

	}
	
}


short PlayNote(short vagID, short priority, short duration)
{ 
 
	u_short i;
	for( i = 1; i < 24; i++)
	{
		if(chanTable[i].duration == 0)
		{
			//chanTable[i].s_attr.addr = vagTable[vagID].addr;	CHRIS PCWipeout
			vagTable[vagID].channelID = i;
			chanTable[i].s_attr.pitch = 0x0800;

			chanTable[i].s_attr.volume.left  = 0x3fff; //sampleLevel;
			chanTable[i].s_attr.volume.right = 0x3fff; //sampleLevel;

	   	// Is this needed, solves repeat ?

			chanTable[i].s_attr.a_mode       = SPU_VOICE_LINEARIncN;	// Attack curve 
  		 	chanTable[i].s_attr.s_mode       = SPU_VOICE_LINEARIncN;	// Sustain curve 
  		 	chanTable[i].s_attr.r_mode       = SPU_VOICE_LINEARDecN;	// Release curve 
  		 	chanTable[i].s_attr.ar           = 0x0;			// Attack rate value 
  	 		chanTable[i].s_attr.dr           = 0x0;			// Decay rate value
	   		chanTable[i].s_attr.sr           = 0x0;			// Sustain rate value 
   			chanTable[i].s_attr.rr           = 0x0;			// Release rate value 
   			chanTable[i].s_attr.sl           = 0xf;			//Sustain level value 

			
 			if ((error!=NO_SOUND) && (SampTable[vagID].Playing==0))
  		     {
   		      if (SampTable[vagID].Loop==0)
      		   {
       			SfxPlay(sfx_handle[vagID],
       					ConvVol(chanTable[i].s_attr.volume.left, chanTable[i].s_attr.volume.right),
       					ConvPan(chanTable[i].s_attr.volume.left, chanTable[i].s_attr.volume.right),
       					15,
       					ConvPitch(chanTable[i].s_attr.pitch), ALL_OFF);
      		   }
   			  else
      		   {
				switch (vagID)
				  {
				  case ENG_AIR_INTAKE:
				  case ENG_RUMBLE:
				  case ENG_THRUST:
				  case CROWD:
				  case REMOTE_ENG:
//				  case SHIELDS:
				  case TURBULENCE:
					    return(0);
						break;
					default:
						break;
				  }
	   			SampTable[vagID].PlayID = SfxPlayId(sfx_handle[vagID],
	   									  ConvVol(chanTable[i].s_attr.volume.left ,chanTable[i].s_attr.volume.right),
	   									  ConvPan(chanTable[i].s_attr.volume.left ,chanTable[i].s_attr.volume.right),
	   									  15,
	   									  ConvPitch(chanTable[i].s_attr.pitch), LOOP_ON);
  	   			SampTable[vagID].Playing = 1;
	   			Channel2Sample[i]=SampTable[vagID].PlayID;
	  		   }
   			 }

			//SpuSetVoiceAttr(&(chanTable[i].s_attr));	PAH! One line only
			//SpuSetKey(SpuOn, (0x1L << i));				 needed with PC power
			chanTable[i].duration = duration;
			chanTable[i].priority = priority;
			chanTable[i].vagID = vagID;
			return(i);
		}					
	}

	/*
	// Have not found an empty channel 
	// therefore consider priority     

	for( i = 1; i < 24; i++)
	{
		if(chanTable[i].duration > 0)
		{
			if(priority < chanTable[i].priority)
			{
				chanTable[i].s_attr.addr = vagTable[vagID].addr;
				vagTable[vagID].channelID = i;
				chanTable[i].s_attr.pitch = 0x0800;
				chanTable[i].s_attr.volume.left = sampleLevel;
				chanTable[i].s_attr.volume.right = sampleLevel;

		   	// Is this needed, solves repeat ? 

				chanTable[i].s_attr.a_mode       = SPU_VOICE_LINEARIncN;	// Attack curve 
	  		 	chanTable[i].s_attr.s_mode       = SPU_VOICE_LINEARIncN;	// Sustain curve 
	  		 	chanTable[i].s_attr.r_mode       = SPU_VOICE_LINEARDecN;	//Release curve 
	  		 	chanTable[i].s_attr.ar           = 0x0;			// Attack rate value 
	  	 		chanTable[i].s_attr.dr           = 0x0;			// Decay rate value 
	   		chanTable[i].s_attr.sr           = 0x0;			// Sustain rate value 
	  	 		chanTable[i].s_attr.rr           = 0x0;			// Release rate value 
	   		chanTable[i].s_attr.sl           = 0xf;			// Sustain level value 

				 											

				SpuSetVoiceAttr(&(chanTable[i].s_attr));
				SpuSetKey(SpuOn, (0x1L << i));
				chanTable[i].duration = duration;
				chanTable[i].priority = priority;
				chanTable[i].vagID = vagID;
				return(i);
			}
		}
	}
	*/	//CHRIS PCWipeout

	return(i);
}	


short PlayDirectionalNote(short vagID, short priority, short duration, VECTOR pos )
{
	u_short 			i;
	VECTOR			distance;
	int				mag;
	int				voll, volr;
	short 			angle;
 	short 		channel;
 
 	channel =-1;
	
	distance.vx = (pos.vx + cameraPtr->camPos->relative.t[0])>>3;
	distance.vy = (pos.vy + cameraPtr->camPos->relative.t[1])>>3;
	distance.vz = (pos.vz + cameraPtr->camPos->relative.t[2])>>3;

	mag = GetMagnitude(distance);
		
	voll = 0x2fff - (mag);
	if(voll < 0) voll = 0;

	volr = 0x2fff - (mag);
	if(volr < 0) volr = 0;

	angle = -ratan2(distance.vx, distance.vz) + cameraPtr->hdg ;
	angle = ang(angle);

	if(angle > 1024) angle = 1024 - (angle - 1024);
	if(angle < -1024) angle = -1024 - (angle + 1024);
  	
	voll += (voll * angle)>>11;
	volr -= (volr * angle)>>11;

	voll = (voll * sampleLevel)>>15;
	volr = (volr * sampleLevel)>>15;

	if((voll > 0) && (volr > 0))
	{
		PlayNote(vagID, priority, duration);
		
		//chanTable[vagTable[vagID].channelID].s_attr.volume.left = voll;
		//chanTable[vagTable[vagID].channelID].s_attr.volume.right = volr;
		
		for(i = 1; i < 24; i++)
  		 {
   		  if ((SampTable[vagID].PlayID == Channel2Sample[i]) && (SampTable[vagID].PlayID !=-1))
		   {
	 		channel=(short)i;
		   }
  		 }
	   chanTable[channel].s_attr.volume.left = voll;
	   chanTable[channel].s_attr.volume.right = volr;

       if ((channel!=-1) && (error!=NO_SOUND) )
        {
         if((SampTable[Channel2Sample[channel]].Playing !=0) && (SampTable[Channel2Sample[channel]].Loop !=0)) 
          {
	   	   chanTable[channel].s_attr.volume.left = voll;
	   	   chanTable[channel].s_attr.volume.right = volr;
		   SfxEffectPitch(SampTable[Channel2Sample[channel]].PlayID,ConvPitch(chanTable[channel].s_attr.pitch));
		   SfxEffectVol(SampTable[Channel2Sample[channel]].PlayID,ConvVol(chanTable[channel].s_attr.volume.left,chanTable[channel].s_attr.volume.right));
		   SfxEffectPan(SampTable[Channel2Sample[channel]].PlayID,ConvPan(chanTable[channel].s_attr.volume.left,chanTable[channel].s_attr.volume.right));
		  }
        }

	   //	SpuSetVoiceAttr(&(chanTable[vagTable[vagID].channelID].s_attr));  CHRIS PCWipeout
	}
	return(1);
}	

void SetPitch(short VagID, short pitch)
{
  	u_short 			i;
 	short 		channel;

		channel =-1;

		if(pitch > 0x3fff) pitch = 0x3fff;
		
		for(i = 1; i < 24; i++)
  		 {
   		  if ((SampTable[VagID].PlayID == Channel2Sample[i]) && (SampTable[VagID].PlayID !=-1))
		   {
	 		channel=(short)i;
		   }
  		 }
		
		if (channel !=-1)
		 {
	      if ((error!=NO_SOUND) && (Channel2Sample[channel]!=-1))				   //	If we can have sound and sample is playing
		   {
		  	if((SampTable[Channel2Sample[channel]].Playing !=0) && (SampTable[Channel2Sample[channel]].Loop !=0))	// If sample loops
		     {
		      chanTable[channel].s_attr.pitch = pitch;
			  SfxEffectPitch(SampTable[Channel2Sample[channel]].PlayID,ConvPitch(chanTable[channel].s_attr.pitch));
		     }
		    }
		  }

	   // SpuSetVoiceAttr(&(chanTable[vagTable[VagID].channelID].s_attr));	CHRIS PCWipeout
}	

void SetVolume(short vagID, short voll, short volr)
{
  u_short 			i;
  short 		channel;
	
		channel =-1;

		if(voll > 0x3fff) voll = 0x3fff;
		if(volr > 0x3fff) volr = 0x3fff;
		
		for(i = 1; i < 24; i++)
  		 {
   		  if ((SampTable[vagID].PlayID == Channel2Sample[i]) && (SampTable[vagID].PlayID!=-1))
		   {
	 		channel=(short)i;
		   }
  		 }
		
		if (channel !=-1)
		 {
	      if ((error!=NO_SOUND) && (Channel2Sample[channel]!=-1))				   //	If we can have sound and sample is playing
		   {
		  	if((SampTable[Channel2Sample[channel]].Playing !=0) && (SampTable[Channel2Sample[channel]].Loop !=0))	// If sample loops
		     {
			  chanTable[channel].s_attr.volume.left = voll;
			  chanTable[channel].s_attr.volume.right = volr;
			  SfxEffectVol(SampTable[Channel2Sample[channel]].PlayID,ConvVol(chanTable[channel].s_attr.volume.left,chanTable[channel].s_attr.volume.right));
			  SfxEffectPan(SampTable[Channel2Sample[channel]].PlayID,ConvPan(chanTable[channel].s_attr.volume.left,chanTable[channel].s_attr.volume.right));
		     }
		    }
		  }
		
		//chanTable[vagTable[vagID].channelID].s_attr.volume.left = voll;			CHRIS PCWipeout
		//chanTable[vagTable[vagID].channelID].s_attr.volume.right = volr;			  me too
	    //SpuSetVoiceAttr(&(chanTable[vagTable[vagID].channelID].s_attr));			  and me
}	



short AdjustDirectionalNote(short vagID, short priority, short duration, VECTOR pos )
{
	u_short 			i;
	VECTOR			distance;
	int				mag;
	int				voll, volr;
	short 			angle;
  	short 			channel;

	
	distance.vx = (pos.vx + cameraPtr->camPos->relative.t[0])>>3;
	distance.vy = (pos.vy + cameraPtr->camPos->relative.t[1])>>3;
	distance.vz = (pos.vz + cameraPtr->camPos->relative.t[2])>>3;

	mag = GetMagnitude(distance);
	mag = mag<<2 ;

	voll = 0x2fff - (mag); /* No Scaling */
	if(voll < 0) voll = 0;

	volr = 0x2fff - (mag); /* No Scaling */
	if(volr < 0) volr = 0;

	angle = -ratan2(distance.vx, distance.vz) + cameraPtr->hdg ;
	angle = ang(angle);

	if(angle > 1024) angle = 1024 - (angle - 1024);
	if(angle < -1024) angle = -1024 - (angle + 1024);
  	
	voll += (voll * angle)>>11;  /* 11 */
	volr -= (volr * angle)>>11;  /* 11 */

	voll = (voll * sampleLevel)>>15;
	volr = (volr * sampleLevel)>>15;

	if((voll > 0) && (volr > 0))
	{
		for(i = 1; i < 24; i++)
  		 {
   		  if ((SampTable[vagID].PlayID == Channel2Sample[i]) && (SampTable[vagID].PlayID !=-1))
		   {
	 		channel=(short)i;
		   }
  		 }
		
		if (channel !=-1)
		 {
	      if ((error!=NO_SOUND) && (Channel2Sample[channel]!=-1))				   //	If we can have sound and sample is playing
		   {
		  	if((SampTable[Channel2Sample[channel]].Playing !=0) && (SampTable[Channel2Sample[channel]].Loop !=0))	// If sample loops
		     {
			  chanTable[channel].s_attr.volume.left = voll;
			  chanTable[channel].s_attr.volume.right = volr;
			  SfxEffectVol(SampTable[Channel2Sample[channel]].PlayID,ConvVol(chanTable[channel].s_attr.volume.left,chanTable[channel].s_attr.volume.right));
			  SfxEffectPan(SampTable[Channel2Sample[channel]].PlayID,ConvPan(chanTable[channel].s_attr.volume.left,chanTable[channel].s_attr.volume.right));
		     }
		    }
		  }

		//chanTable[vagTable[vagID].channelID].s_attr.volume.left = voll;	  CHRIS PC Wipeout
		//chanTable[vagTable[vagID].channelID].s_attr.volume.right = volr;	  CHRIS PC Wipeout
	    //SpuSetVoiceAttr(&(chanTable[vagTable[vagID].channelID].s_attr));	  CHRIS PC Wipeout
	}
	return(1);
}	


short AdjustRemoteEngineSound(ShipData *shipIndex, Object** shipShapes, TrackCamera *camera )
{
	u_short 			i;
	VECTOR			distance;
	int				mag , smallestMag[3];
	short				ident[3];
	int				voll, volr;
	short 			angle;
	VECTOR			dopler;
	int				doplerMag;
	
	smallestMag[0] = 14000;
	smallestMag[1] = 14000;
	smallestMag[2] = 14000;
	ident[0] = -1;
	ident[1] = -1;
	ident[2] = -1;

	for(i = 0; i < NO_OF_SHIPS; i++)
	{
		if((i != ownShip) && ((ownShip & RACING)== 0))
		{
			distance.vx = (shipIndex[i].ppivot.vx + camera->camPos->relative.t[0]) >>3;
			distance.vy = (shipIndex[i].ppivot.vy + camera->camPos->relative.t[1]) >>3;
			distance.vz = (shipIndex[i].ppivot.vz + camera->camPos->relative.t[2]) >>3;

			mag = GetMagnitude(distance);
		
			if(mag < smallestMag[0])
			{
				if(ident[0] != -1)
				{
					smallestMag[1] = smallestMag[0];
					ident[1] = ident[0];
				}
				smallestMag[0] = mag;
				ident[0] = i;
			}
			else if(mag < smallestMag[1])
			{
				smallestMag[1] = mag;
				ident[1] = i;
			}
		}
	}

	for(i = 0; i < 2; i++)
	{
		if(ident[i] > -1)
		{
			distance.vx = (shipIndex[ident[i]].ppivot.vx + camera->camPos->relative.t[0]) >>3;
			distance.vy = (shipIndex[ident[i]].ppivot.vy + camera->camPos->relative.t[1]) >>3;
			distance.vz = (shipIndex[ident[i]].ppivot.vz + camera->camPos->relative.t[2]) >>3;

			mag = GetMagnitude(distance);

			if(mag > 1000)
				voll = 0x2fff - ((mag-1000)<<2);
			else
				voll = 0x2fff;
			if(voll < 0) voll = 0;

			if(mag > 1000)
				volr = 0x2fff - ((mag-1000)<<2);
			else
				volr = 0x2fff;
			if(volr < 0) volr = 0;

			angle = -ratan2(distance.vx, distance.vz) + camera->hdg ;
			angle = ang(angle);

			if(angle > 1024) angle = 1024 - (angle - 1024);
			if(angle < -1024) angle = -1024 - (angle + 1024);

			voll += (voll * angle)>>11;
			volr -= (volr * angle)>>11;

			voll = (voll * sampleLevel)>>15;
			volr = (volr * sampleLevel)>>15;

			dopler.vx = (shipIndex[ident[i]].vpivot.vx>>6) - camera->vel.vx;
			dopler.vy = (shipIndex[ident[i]].vpivot.vy>>6) - camera->vel.vy;
			dopler.vz = (shipIndex[ident[i]].vpivot.vz>>6) - camera->vel.vz;

			dopler.vx += distance.vx;
			dopler.vy += distance.vy;
			dopler.vz += distance.vz;

			doplerMag = mag - GetMagnitude(dopler) ;

			SetPitch(REMOTE + i, 0x0800 + doplerMag);
			SetVolume(REMOTE + i, voll, volr);

		}
		else
		{
			SetVolume(REMOTE + i, 0, 0);
		}
	}
	return(1);
}	

/*********************************************************************/
/**** WiPe OuT specific functions to adjust in game sound effects ****/
/*********************************************************************/

void AdjustEngineSound(ShipData *playerShip, TrackCamera *camera)
{
	short vol;
	short vol2;
	short pitch;
	short noteChange;
	short breakPoint;

	if(camera->section->faceCount > 4)
	{
		if(r_attr.depth.left < (4571*camera->section->faceCount))
		{
			r_attr.depth.left += 1000;
			r_attr.depth.right += 1000;
			SpuSetReverbDepth(&r_attr);
		}
	}
	else
	{
		if(r_attr.depth.left > 2000)
		{
			r_attr.depth.left -= 1000;
			r_attr.depth.right -= 1000;
			SpuSetReverbDepth(&r_attr);
		}
	}
	/******************************************/
	/****  				ENGINE 2					****/
	/******************************************/

  	vol = (ENG_AIR_INTAKE_VOL * playerShip->speed) >> 15;
	if(vol > ENG_AIR_INTAKE_VOL) vol = ENG_AIR_INTAKE_VOL;

	/*** 			Pitch Increment 0x1000 				***/
	/***	Pitch was started at 42 + 4 octaves    ***/

	pitch = playerShip->speed >> 2;

	SetPitch(ENG_AIR_INTAKE, 0x0800 + pitch);
	SetVolume(ENG_AIR_INTAKE, vol, vol);

	vol = 375 + ((ENG_THRUST_VOL * playerShip->thrust_mag) / playerShip->max_thrust);

	pitch = (0x7ff * playerShip->thrust_mag) / playerShip->max_thrust;
	pitch += playerShip->speed >> 5;

	/*** 			Pitch Increment 2048 				***/
	/***	Pitch was started at 55 + 2 octaves    ***/

	SetPitch(ENG_THRUST, 0x1000 + pitch);
	SetVolume(ENG_THRUST, vol, vol);

	vol = 750 + ((REMOTE_ENG_VOL * playerShip->thrust_mag) / playerShip->max_thrust);

	pitch = (0x3ff * playerShip->thrust_mag) / playerShip->max_thrust;
	pitch += playerShip->speed >> 5;

	/*** 			Pitch Increment 2048 				***/
	/***	Pitch was started at 55 + 2 octaves    ***/

	SetPitch(REMOTE_ENG, 0x0800 + pitch);
	SetVolume(REMOTE_ENG, vol, vol);

	/******************************************/
	/****  	  TURBULANCE & AIR BRAKES		****/
	/******************************************/

	/******* Needs re-balancing ********/

	vol = playerShip->speed >> 1 ;	
/*
	s_attr[TURBULENCE].volume.left = (vol>>2) + ((vol * playerShip->r_brake_rot)>>9);
	s_attr[TURBULENCE].volume.right = (vol>>2) + ((vol * playerShip->l_brake_rot)>>9);
	SpuSetVoiceAttr(&(s_attr[TURBULENCE]));
*/
	SetVolume(TURBULENCE, (vol>>2) + ((vol * playerShip->r_brake_rot)>>9), (vol>>2) + ((vol * playerShip->l_brake_rot)>>9));

}

int InitCD(CdlLOC* loc, int trackNo)
{
	u_char	param;
	int		i;

//	param = CdlModeRept|CdlModeDA;		//PCWipeout
//	CdControlB(CdlSetmode, &param, 0);	//PCWipeout
	ntoc = CdGetToc(loc);			
//	for (i = 1; i < ntoc; i++) 			//PCWipeout
//		CdIntToPos(CdPosToInt(&loc[i]) - 74, &loc[i]);	//PCWipeout
//	CdSetDebug(0);						//PCWipeout
//   SpuSetCommonAttr (&c_attr);		//PCWipeout
#if 0
	if(ntoc > 0)
	{
		if(ntoc < trackNo)
		{
			trackNo = (rand() % (ntoc-1)) + 2;
		}
		if(trackNo == 0)
		{
			trackNo = (rand() % (MAX_CD_TRACKS-1)) + 2;
		}
		CdControlB(CdlSetloc, (u_char *)&loc[trackNo], 0);	
		CdControlB(CdlPlay, 0, 0);  

	}
#endif
	return(ntoc);
}

int InitCrowdSound(Object** prm, short prmCount, Object **lostad, int stadCount)
{
	int 			i, j;
   Object      *obj;

	for( i = 0; i < prmCount; i++)
	{
      obj = prm[ i ];
      while ( obj )
      {
		  	if(!strncmp(&(obj->name), "lost", 4))
			{
				lostad[stadCount] = obj;
				stadCount++;

//				printf("Stadium = %s \n", &(obj->name) );
			}

         obj = obj->next;
      }

	}
	return(stadCount);
}



void AdjustCrowdSound(Object **lostad, int stadCount)
{
 	short 		channel;

	int i;
	VECTOR	distance;
	short 	vol;
	int 		mag, mag2;
	int		chosen[2];
	int 		smallestMag[2];
	VECTOR	pos;

	channel =-1;

	smallestMag[0] = 10000;
	smallestMag[1] = 10000;
	chosen[0] = -1;
	chosen[1] = -1;

	for(i = 0; i < stadCount; i++)
	{ 
		distance.vx = (lostad[i]->skeleton->relative.t[0] + cameraPtr->camPos->relative.t[0])>>3;
		distance.vy = (lostad[i]->skeleton->relative.t[1] + cameraPtr->camPos->relative.t[1])>>3;
		distance.vz = (lostad[i]->skeleton->relative.t[2] + cameraPtr->camPos->relative.t[2])>>3;

    	mag = GetMagnitude(distance);

		if(mag < smallestMag[0])
		{
			if(chosen[0] != -1)
			{
				smallestMag[1] = smallestMag[0];
				chosen[1] = chosen[0];
			}
			smallestMag[0] = mag;
			chosen[0] = i;
		}
		else if(mag < smallestMag[1])
		{
			smallestMag[1] = mag;
			chosen[1] = i;
		}
	}


	if(smallestMag[0] < 8192)
	{
		pos.vx = lostad[chosen[0]]->skeleton->relative.t[0];
		pos.vy = lostad[chosen[0]]->skeleton->relative.t[1];
		pos.vz = lostad[chosen[0]]->skeleton->relative.t[2];
		
		AdjustDirectionalNote(CROWD, 0, -1, pos );
	}
	else
	{
		for(i = 1; i < 24; i++)
  		 {
   		  if ((SampTable[CROWD].PlayID == Channel2Sample[i]) && (SampTable[CROWD].PlayID!=-1))
		   {
	 		channel=(short)i;
		   }
  		 }
		if (channel !=-1)
		 {
		  chanTable[channel].s_attr.volume.left = 0;
		  chanTable[channel].s_attr.volume.right = 0;
		  SfxStop(SampTable[Channel2Sample[channel]].PlayID);
		  SampTable[Channel2Sample[channel]].Playing=0;
		  SampTable[Channel2Sample[channel]].PlayID=-1;
		 }
	}

	if(smallestMag[1] < 8192)
	{
		pos.vx = lostad[chosen[1]]->skeleton->relative.t[0];
		pos.vy = lostad[chosen[1]]->skeleton->relative.t[1];
		pos.vz = lostad[chosen[1]]->skeleton->relative.t[2];
		
		AdjustDirectionalNote(CROWD2, 0, -1, pos );

	}
	else
	{	

		for(i = 1; i < 24; i++)
  		 {
   		  if ((SampTable[CROWD].PlayID == Channel2Sample[i]) && (Channel2Sample[CROWD] !=-1))
		   {
	 		channel=(short)i;
		   }
  		 }
	 
	if (channel !=-1)
		 {
		  chanTable[channel].s_attr.volume.left = 0;
		  chanTable[channel].s_attr.volume.right = 0;
		  SfxStop(SampTable[Channel2Sample[channel]].PlayID);
		  SampTable[Channel2Sample[channel]].Playing=0;
		  SampTable[Channel2Sample[channel]].PlayID=-1;
		 }

	}


	if (error!=NO_SOUND)
	 {
	  channel =-1;

	  for(i = 1; i < 24; i++)
  	   {
   		if ((SampTable[CROWD].PlayID == Channel2Sample[i]) && (Channel2Sample[i] !=-1))
		   {
	 		channel=(short)i;
		   }
  	   }

	  if (channel !=-1)
	   {
	    if (error!=NO_SOUND)
         {
          if((SampTable[CROWD].Playing !=0) && (SampTable[CROWD].Loop !=0)) 
           {
		    SfxEffectPitch(SampTable[Channel2Sample[channel]].PlayID,ConvPitch(chanTable[channel].s_attr.pitch));
		    SfxEffectVol(SampTable[Channel2Sample[channel]].PlayID,ConvVol(chanTable[channel].s_attr.volume.left,chanTable[channel].s_attr.volume.right));
		    SfxEffectPan(SampTable[Channel2Sample[channel]].PlayID,ConvPan(chanTable[channel].s_attr.volume.left,chanTable[channel].s_attr.volume.right));
		   }
	     }
       }
	 }
	//SpuSetVoiceAttr(&(chanTable[vagTable[CROWD].channelID].s_attr));
	//SpuSetVoiceAttr(&(chanTable[vagTable[CROWD2].channelID].s_attr));

}

